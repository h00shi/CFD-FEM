#include "LinearSolver/MKLDSS.h"
//****************************************************************************80
MKLDSS::MKLDSS(CSRMatrix<realT>& matrix) : matrix_(matrix)
{
  //---> Call the create function
  Create();
}
//****************************************************************************80
MKLDSS::~MKLDSS()
{
  Delete();
}
//****************************************************************************80
void MKLDSS::Create()
  {
    intT nrow = matrix_.get_nrow();
    intT nnz  = matrix_.get_nnz();
#ifdef MKL_DSS
    //------------------------ CREATE DSS OBJECT ---------------------------
    const MKL_INT mkl_dss_create_opt = mkl_dss_zero_based_indexing;
    MKL_INT create_return = dss_create(mkl_handle_,
                                       mkl_dss_create_opt);

    switch (create_return){// DSS Error Trap
    case MKL_DSS_SUCCESS:
      //---> Creation of DSS handle object was successful
      break;
    case MKL_DSS_OUT_OF_MEMORY:
      SystemModule::cout << " ERROR: MKL Direct Spare Solver(DSS) "
                << " has returned an out of memory error.  The MKL DSS"
                << " solver is not under CMT control.  Please check the"
                << " memory report generated by the solver and compare"
                << " against machine specs.  If the amount of memory per"
                << " node is < the amount "
                << " allocated per node for any node then you need to"
                << " use more nodes.  Also ensure your stack is set to "
                << " unlimited. "
                << std::endl;
#ifdef DEV_DEBUG
      SystemModule::cout << " DEV DEBUG: Error occurred in MatrixCSR.h near line"
                << std::endl;
#endif
      break;
    case MKL_DSS_INVALID_OPTION:
      SystemModule::cout << "ERROR: MKL DSS was given an invalid "
                << "option...not sure what this means yet."
                << std::endl;
      break;
    }// End DSS Error trap

    //----------------------- DEFINE THE MATRIX ----------------------------

    //const MKL_INT mkl_dss_define_opt = mkl_dss_non_symmetric;
    MKL_INT define_return =
      dss_define_structure(mkl_handle_,
                           mkl_dss_non_symmetric,
                           matrix_.get_row_offset().get_ptr(0),
                           nrow,
                           nrow,
                           matrix_.get_column_idx().get_ptr(0,0),
                           nnz);
    switch (define_return){// DSS Define error trap
    case MKL_DSS_SUCCESS:
      //---> Creation of DSS handle object was successful
      break;
    default:
#ifdef DEV_DEBUG
      SystemModule::cout << " ERROR: Intel MKL Direct Spare Solver (DSS)  "
                << " is not able to be defined." << std::endl;
      SystemModule::cout << " In file MatrixCSR.h::Factorize()." << std::endl;
      SystemModule::cout << " Value of define_return = " << define_return;
#endif
    }// End DSS Define error trap

    //--------------------- REORDER THE MATRIX -----------------------------
    intT mkl_perm2[1];
    mkl_perm2[0] = 0;
    MKL_INT mkl_dss_reorder_opt = MKL_DSS_AUTO_ORDER;
    MKL_INT reorder_return = dss_reorder(mkl_handle_,
                                         mkl_dss_reorder_opt,
                                         mkl_perm2);

    switch (reorder_return){// DSS reorder error trap
    case MKL_DSS_SUCCESS:
      //---> Creation of DSS handle object was successful
      break;
    default:
#ifdef DEV_DEBUG
      SystemModule::cout << "ERROR: Intel MKL Direct Spare Solver (DSS)  "
                << "is not able to conduct reorder operation."
                << std::endl;
      SystemModule::cout << " In file MatrixCSR.h::Factorize()." << std::endl;
      SystemModule::cout << " Value of reorder_return = " << reorder_return
                << std::endl;
#endif
    }// End DSS Define error trap
#endif

    return;
  } // End Create
//****************************************************************************80
void MKLDSS::Delete() {

#ifdef MKL_DSS
      //MKL_INT delete_return = 
      dss_delete(mkl_handle_, mkl_dss_defaults);
#endif

    } // End MKLDSSDelete
//****************************************************************************80
bool MKLDSS::Factorize()
{
      
  //---> Variable to track wether or no factorization was sucessful
  bool is_factorized = false;

#ifdef MKL_DSS
  //--------------------- FACTORIZE THE MATRIX ---------------------------
  MKL_INT mkl_dss_factor_opt = mkl_dss_indefinite;
  MKL_INT factor_return = dss_factor_real(mkl_handle_,
                                          mkl_dss_factor_opt,
                                          matrix_.get_data().get_ptr(0));


  switch (factor_return){// DSS factor error trap
  case MKL_DSS_SUCCESS:
    //---> Creation of DSS handle object was successful
    break;
  default:
#ifdef DEV_DEBUG
    SystemModule::cout << "ERROR: Intel MKL Direct Spare Solver (DSS)  "
              << "is not able to conduct factorization operation."
              << std::endl;
    SystemModule::cout << " In file MatrixCSR.h::Factorize()." << std::endl;
    SystemModule::cout << " Value of factor_return = " << factor_return
              << std::endl;
#endif
    break;
  }// DSS factor error trap

  //-------------------------------- RETURN ------------------------------
  if( factor_return == MKL_DSS_SUCCESS ) {is_factorized = true;}
#endif

  return(is_factorized);
} // End MKLDSS::Factorize
//****************************************************************************80
void MKLDSS::Solve(const List2D<double>& b, List2D<double>& x)
{

#ifdef MKL_DSS
  const MKL_INT nrhs = 1;
  //MKL_INT solve_return = 
  dss_solve_real(mkl_handle_, mkl_dss_defaults,
                 b.get_ptr(0,0), nrhs,
                 x.get_ptr(0,0));
#endif
} // End MKLDSS::Solve
